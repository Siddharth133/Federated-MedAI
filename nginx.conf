import logging
import threading
import time
from datetime import datetime
from threading import Thread, Lock
from pha_resources import pha_helper, pha_vmomi_wrapper, pha_sync_manager
from utils import cred_store

log = logging.getLogger(__name__)

def clear_vc_ov_dict(host_list):
    try:
        ov_vc_keys = list(PollManager_VC.vc_ov_dict.keys())
        uuids_to_be_deleted = [host["uuid"] for host in host_list if host["uuid"] in ov_vc_keys]
        log.info("uuids to be removed: %s", uuids_to_be_deleted)
        for uuid in uuids_to_be_deleted:
            del PollManager_VC.vc_ov_dict[uuid]
    except Exception as e:
        log.exception(e) 
    

class PollManager_VC:
    vc_hosts = dict()
    vc_objs_dict = dict()
    vc_ov_dict = dict()

    def __init__(self,configData):
        self.configData = configData
        log.debug("configData passed to pollmanager_vc is :%s",self.configData)
        self.vc_threads = dict() 

        self.vc_poll = Thread(name="vcenter.PollManager_vc.vc_poll", target=self.run_vc_poll)
        self.vc_poll.daemon = True
        self.vc_poll._stopevent = threading.Event()

        self.heartBeat_poll = Thread(name="PollManager_vc.Provider_heartbeat", target=self.healthUpdateTimer)
        self.heartBeat_poll.daemon = True
        self.heartBeat_poll._stopevent = threading.Event()
        self.heartBeat_poll.start()

    def healthUpdateTimer(self):
        '''
        This is a separate Thread that runs for every three minutes.
        If Vcenter does not see any updates for certain time it would think that our provider to be stale.
        To avoid this we provide an empty update as a heart beat for every 3 minutes.
        This function checks the difference between lastHealthUpdateTime and curent time and if it is greater than 3 minutes
        it will post an empty Health update.
        '''
        log.debug("This is in health Update Timer.")
        heartBeatInterval = None
        try:
            heartBeatInterval = int(self.configData.PHA_PROVIDER_HEARTBEAT)
        except:
            log.exception("unable to get heartbeat time interval for HPE provider from ProactiveHA config file")
        
        if not heartBeatInterval:
            log.debug("setting default time for heartbeat for hpe provider to 3 minutes.")
            heartBeatInterval= 180

        while not self.heartBeat_poll._stopevent.isSet():
            try:
                '''
                for each item in vc_objs_dict
                '''
                for k,v in PollManager_VC.vc_objs_dict.items():
                    t1 = datetime.now()
                    dummyHealthObj = {}
                    if v.lastHealthUpdateTime:
                        t2 = v.lastHealthUpdateTime
                        delta = t1-t2
                        #3 minutes
                        if delta.seconds>180:
                            log.info('HPE provider heartbeat for vcenter : %s ',k)
                            v.postHealthUpdates(dummyHealthObj,emptyHealthUpdate=True) 
                    else:
                        #posting an empty health update for first time
                        log.info('HPE provider first heartbeat for vcenter : %s ',k)
                        v.postHealthUpdates(dummyHealthObj,emptyHealthUpdate=True) 
            except:
                log.exception("Encountered a error retrieving last known health update time to vcenter threads")
                
            time.sleep(heartBeatInterval)

    def run_vc_poll(self):
        '''
        This function will start a thread for each vcenter credential  that is found in credential store.
        This will also initialize and delete few data structures.  
        '''    
        log.debug("This is in run_vc_poll.")

        vc_poll_sleepTime = None
        try:
            vc_poll_sleepTime = int(self.configData.PHA_VCENTER_POLL)
        except:
            log.exception("unable to get vcenter poll time interval from proactive HA config file")

        if not vc_poll_sleepTime:
            log.debug("setting vcenter poll interval to default of 5 minutes(300 seconds)")
            vc_poll_sleepTime = 300

        while not self.vc_poll._stopevent.isSet():
            try:
                vc_creds = cred_store.get_all_vcenter_creds()
                current_creds_IP = []
                new_vc_thread_counter =0
                
                for each_vc in vc_creds:
                    try:
                        current_creds_IP.append(each_vc['ip'])
                        if each_vc['ip'] in self.vc_threads:
                            if self.vc_threads[each_vc['ip']].is_alive():
                                log.info("%s vcenter thread is alive.",each_vc['ip'])
                            else:
                                log.info("%s vcenter thread is NOT alive",each_vc['ip'])
                                del self.vc_threads[each_vc['ip']]
                                clear_vc_ov_dict(PollManager_VC.vc_hosts[each_vc['ip']])
                                                                         
                                del PollManager_VC.vc_objs_dict[each_vc['ip']]
                                del PollManager_VC.vc_hosts[each_vc['ip']]
                                thread_started = self.start_vcenterThread(each_vc)
                                if thread_started:
                                    new_vc_thread_counter+=1
                                else:
                                    log.info("unable to start vcenter(%s) thread, vcenter version might be less than 6.5 or cannot connect to VCSA appliance.",each_vc['ip'])
                        else:
                            log.info("added new vcenter :%s to credential store",each_vc['ip'])
                            thread_started = self.start_vcenterThread(each_vc)
                            if thread_started:
                                new_vc_thread_counter+=1
                            else:
                                log.info("unable to start vcenter(%s) thread, vcentter version might be less than 6.5 or cannot connect to VCSA appliance.",each_vc['ip'])
                    except:
                        log.exception("Error in creating new thread or registering HPE provider vcenter.")

                #Stop the threads of vcenter Instances that got removed and delete them
                #unregister the HPE provider from that vcenter
                for key in list(self.vc_threads.keys()):
                    try:
                        if key not in current_creds_IP:
                            log.info("vcenter : %s is removed from credential Store",key)
                            if self.vc_threads[key].is_alive():
                                log.debug("thread for vcenter : %s is still alive",key)
                                self.vc_threads[key].stop()
                                log.info("Deleted vcenter %s thread  and now unregistering HPE provider from the vcenter",key)
                                try:
                                    PollManager_VC.vc_objs_dict[key].unregister_proactiveha()
                                except Exception as e:
                                    log.exception("Exception occurred while unregistering HPE Proactive HA provider from Vcenter : %s",e)
                                
                                clear_vc_ov_dict(PollManager_VC.vc_hosts[key])
                                del PollManager_VC.vc_objs_dict[key]
                                del PollManager_VC.vc_hosts[key]
                                del self.vc_threads[key]
                                log.debug("vcenter threads : %s",self.vc_threads)
                                log.debug("vcenter hosts : %s",PollManager_VC.vc_hosts)
                    except:
                        log.exception("Error in deleting vcenter threads, that was removed from CredentialStore.")

                if new_vc_thread_counter > 0:
                    log.info("sync status called from pha_vc_manager")
                    pha_sync_manager.syncStatus()
                else:
                    log.debug("There are no new vcenters added or restarted in this cycle so there is no necessity for status sync on health updates.")

                #checking if heartbeat thread is alive if not restarting it
                if self.heartBeat_poll.is_alive():
                    log.debug("heartBeat_poll thread is alive.")
                else:
                    log.debug("heartBeat_poll thread is not alive so restarting the thread.")
                    self.heartBeat_poll.start()
                
                # check if any change in ov data
                pha_sync_manager.PollManager_Sync.run_ov_poll()

                time.sleep(vc_poll_sleepTime)

            except:
                log.exception("Encountered a error retrieving Vcenter credentials and starting vcenter threads")
        
    def start_vcenterThread(self, vc_cred):
        '''
        This function creates and starts the vcenter listener threads.
        '''

        vc_client = pha_vmomi_wrapper.PHAVcenterClient(vc_cred.get("ip"),self.configData)
        ret_value = False

        try:
            vc_client.login(vc_cred)
            if vc_client.session:
                PollManager_VC.vc_objs_dict[vc_cred['ip']] = vc_client
                t = Vcenters_thread_Manager(vc_client,self.configData)
                self.vc_threads[vc_cred['ip']] = t
                t.daemon = True
                t.start()
                ret_value = True
            else:
                log.error('Failed to obtain a valid vcenter session for : %s', vc_cred['ip'])

        except Exception as e:
            log.exception('Unable to login to vCenter %s', vc_cred['ip'])
            log.exception(e)
        
        return ret_value
    
    def start(self):
        self.vc_poll.start()

    def stop(self):
        '''
        Stoping all the threads and cleaning up dictionaries and other data 
        '''
        #Send the event to stop the Vcenters polling thread
        self.vc_poll._stopevent.set()

        #Send the event to stop the Heartbeat polling thread
        self.heartBeat_poll._stopevent.set()

        #Stop all the listner threads and delete them
        for key in self.vc_threads.keys():
            if self.vc_threads[key].is_alive():
                self.vc_threads[key].stop()
                del self.vc_threads[key]

        # clean up vcenter objects dictionary
        del PollManager_VC.vc_objs_dict 

        #deleting vcenter hosts that contains hosts uuid,virtualuuids
        del PollManager_VC.vc_hosts

        #deleting vcenter host with ov uri
        del PollManager_VC.vc_ov_dict
 
    @staticmethod
    def sync_OV_VC_MonitoredHosts():
        '''
        This function will loop through all known vcenters and sync the monitored host list for HPE provider in each Vcenter.

        '''
        try:
            
            full_host_list = []
            vc_hosts_dict_copy = {k:v for k,v in PollManager_VC.vc_hosts.items() if v}
            for k,v in vc_hosts_dict_copy.items():
                for host in v:
                    host["vc_name"] = k
                full_host_list.extend(v)
            
            if len(full_host_list) > 0:
                hostList = pha_helper.get_vc_ov_hosts(full_host_list)
                for host in hostList:
                    PollManager_VC.vc_ov_dict[host["uuid"]] = host["host_ov_uri"]
                
                vc_obj_dict_copy = {k:v for k,v in PollManager_VC.vc_objs_dict.items() if v}
                for k,v in vc_obj_dict_copy.items():
                    log.debug("items in PollManager_VC.vc_objs_dict : %s  and  %s",k,v)
                    log.info("Syncing monitored hosts in vCenter : %s ",k)
                    try:
                        hostListToSync = [host for host in hostList if host["vc_name"] == k]
                        v.syncMonitoredHostList(hostListToSync)
                    except:
                        log.exception("Error in syncing the hostlist between oneview hosts and Vcenter : %s",k)
        except:
            log.exception("Unable to sync monitored host list between OneView and Vcenter.")
            raise

class Vcenters_thread_Manager(Thread):
    def __init__(self, vc,configData, group=None, target=None, name=None, verbose=None):
        super(Vcenters_thread_Manager, self).__init__(group=group, target=target,
                                               name=name)
        self.vc_obj = vc
        self.config = configData
        self._stopevent = threading.Event()

    def run(self):
        '''
        #get hosts from vcenter through check for updates
        #register HPE provider with HAProactive in Vcenter
        #Add vcenter hosts as monitored hosts
        #loop every 10 minutes to check for updates on hosts
        run an infinite loop constantly get updates from vcenters        
        '''
        try:
            versionStr, host_uuid_data = self.processCheckForUpdate()
            PollManager_VC.vc_hosts[self.vc_obj.host] = host_uuid_data
            hostList = pha_helper.get_vc_ov_hosts(PollManager_VC.vc_hosts[self.vc_obj.host])
            
            ## add ov_uri for found host
            for ov_host in hostList:
                PollManager_VC.vc_ov_dict[ov_host["uuid"]] = ov_host["host_ov_uri"]
            
            
            provider_id = self.vc_obj.getHPEProviderId()
            if provider_id:
                #provider already exists
                #so query for monitored hosts and 
                #compare if all the hosts from host list to result from querymonitoredhosts
                # for any host that is not in the list call addmonitoredhost
                monitored_hosts = self.vc_obj.get_ha_monitored_entities(provider_id)
                if hostList and len(hostList)>0:
                    if monitored_hosts:
                        for cached_vc_host in hostList:
                            host_found = False
                            for eachHost in monitored_hosts: 
                                if eachHost._moId == cached_vc_host.get("moId"):
                                    host_found = True
                                    break
                            if not host_found:
                                self.vc_obj.add_initialize_host([cached_vc_host], provider_id)
                    else:
                        log.debug("There are no monitored hosts so adding known OV_VC hosts as monitored hosts.")
                        self.vc_obj.add_initialize_host(hostList, provider_id)
                else:
                    log.debug("host list is empty")
            else:
                provider_id = self.vc_obj.registerHealthUpdateProvider()
                if provider_id and hostList and len(hostList)>0:
                    self.vc_obj.add_initialize_host(hostList, provider_id)

            log.debug("sleeping for 30 seconds before making a call to checkforupdates again.")
            time.sleep(30)
            vcenter_host_update_poll = None
            
            try:
                vcenter_host_update_poll = int(self.config.PHA_VCENTER_HOSTUPDATE_POLL)
            except:
                log.exception("unable to get poll interval for  hosts updates in vcenter from proactiveHAconfig file.")

            if not vcenter_host_update_poll:
                log.debug("unable to read polling time interval from config file so assigning a default ime of 120 seconds.")
                vcenter_host_update_poll = 120

            while not self._stopevent.isSet():
                try:
                    if not self.vc_obj.is_valid_session():
                        self.stop()
                        raise Exception("Not valid session, stopping this thread")
                    hostdata  = self.vc_obj.checkHostUpdates(versionStr)
                    if hostdata:
                        log.debug("hostdata from check for updates call is :%s",hostdata)
                        versionStr = hostdata.version
                        host_list_to_add = []
                        host_list_to_remove = []
                        providerId = self.vc_obj.getHPEProviderId()
                        for eachHostObj in hostdata.filterSet[0].objectSet:
                            try:
                                if eachHostObj.kind == 'enter':
                                    host_uuid_data = self.getHostData(eachHostObj)
                                    log.debug("data received to add: %s", host_uuid_data)
                                    if host_uuid_data and "moId" in list(host_uuid_data.keys()):
                                        PollManager_VC.vc_hosts[self.vc_obj.host].append(host_uuid_data)
                                        host_list_to_add.append(host_uuid_data)
                                    else:
                                        log.error("host data not proper: %s", host_uuid_data)
                                elif eachHostObj.kind == 'leave':
                                    host_uuid_data = self.getHostData(eachHostObj)
                                    log.debug("data received to delete: %s", host_uuid_data)
                                    if host_uuid_data and "moId" in list(host_uuid_data.keys()):
                                        host_list_to_remove.append(host_uuid_data)
                                    else:
                                        log.error("host data not proper: %s", host_uuid_data)
                                elif eachHostObj.kind == 'modify':
                                    log.info("host info has been updated @ vcenter : %s",self.vc_obj.host)
                                    host_uuid_data = self.getHostData(eachHostObj)
                                    updated = self.check_update_vc_hosts(host_uuid_data)
                                    if updated:
                                        host_list_to_add.append(host_uuid_data)
                            except:
                                log.exception("Exception occurred when processing enter/remove/modify updates from vcenter, continuing with other hosts in the list.")

                        if len(host_list_to_add)>0:
                            self.add_ov_vc_host(host_list_to_add, providerId)
                        if len(host_list_to_remove)>0:
                            self.remove_monitored_host(host_list_to_remove, providerId)

                    else:
                        log.info("there are no host updates to vcenter(%s) since last checkforupdates call",self.vc_obj.host)
                except:
                    log.exception("Error in getting host updates from property collecter of vcenter(%s) and cannot perform add,delete or modify operations.",self.vc_obj.host)
                    raise

                time.sleep(vcenter_host_update_poll)
        except Exception as e:
            log.exception("unable to run vcenter host monitoring thread for %s",self.vc_obj.host)
            raise
        finally:
            log.info("thread manager stopped for %s", self.vc_obj.host)
            self.stop()
            self.vc_obj = None
            self.config = None
        
    def remove_monitored_host(self, vc_host_list, provider_id):
        try:
            if provider_id and len(vc_host_list)>=1:
                is_host_removed = self.vc_obj.addRemoveMonitoredHosts(vc_host_list, provider_id, pha_vmomi_wrapper.MonitoredEntityAction.remove)
                log.debug("is host removed : %s",is_host_removed)
            else:
                log.error("Unable to find the hosts that are removed from vcenter.")
        except:
            log.exception("Unable to remove host from Monitored host list.")
        only_uuids = [h["moId"] for h in vc_host_list]
        
        #delete the host uuids from ov_host and ov_vc_host dictionary
        if only_uuids and len(only_uuids) > 0:
            log.debug("host to be removed: %s", only_uuids)
            host_to_remove = [host for host in PollManager_VC.vc_hosts[self.vc_obj.host] if host["moId"] in only_uuids]
            clear_vc_ov_dict(host_to_remove)
            
            found_objs = [host for host in PollManager_VC.vc_hosts[self.vc_obj.host] if host["moId"] not in only_uuids]
            del PollManager_VC.vc_hosts[self.vc_obj.host]
            PollManager_VC.vc_hosts[self.vc_obj.host] = found_objs
            log.info("all hosts from vcenter after removal are : %s",PollManager_VC.vc_hosts[self.vc_obj.host])
            log.info("all ov_vc hosts from vcenter after removal are : %s",PollManager_VC.vc_ov_dict)
        
    def add_ov_vc_host(self,vc_host_list, provider_id):
        ov_host_data = pha_helper.get_vc_ov_hosts(vc_host_list)
        # add to ov_vc_host_list
        for ov_host in ov_host_data:
            PollManager_VC.vc_ov_dict[ov_host["uuid"]] = ov_host["host_ov_uri"]

        if len(ov_host_data)>0:
            log.debug("host found in one of the known oneviews")
            if provider_id:
                self.vc_obj.add_initialize_host(ov_host_data, provider_id)
            else:
                log.error("unable to find HPE provider")
        else:
            log.info("hosts does not belong to any of the known HPE OneViews %s", vc_host_list)
   
    def check_update_vc_hosts(self,hostData):
        '''
        if the type of checkforupdates call result is modify we check if that host data exists in PollManager_VC.vc_hosts dataStructure.
        if Host got only half data during an update cycle and remaining half i the next update cycle
        this function will make sure there are no duplicates or hosts with half data 
        in the vc_hosts data structure
          
        if this host exists then we will replace it the modified data and return True
        else return False
        '''
        log.debug("in check update vc hosts function")
        retValue = False        
        temp_host_list=[]
        try:
            log.debug("vcenter hosts are : %s",PollManager_VC.vc_hosts[self.vc_obj.host])
            for eachObj in PollManager_VC.vc_hosts[self.vc_obj.host]:
                if eachObj.get('moId') and eachObj.get('model') and eachObj.get('uuid') and eachObj.get('name') :
                    temp_host_list.append(eachObj)
                else:
                    if hostData.get('moId') and hostData.get('moId','unavailable') == eachObj.get('moId','unknown'):
                        temp_dict = {}
                        temp_dict['moId'] = hostData.get('moId')
                        
                        if eachObj.get('model'):
                            temp_dict['model'] = eachObj.get('model')
                        elif hostData.get('model'):
                            temp_dict['model'] = hostData.get('model')

                        if eachObj.get('name'):
                            temp_dict['name'] = eachObj.get('name')
                        elif hostData.get('name'):
                            temp_dict['name'] = hostData.get('name')
                            
                        if eachObj.get('uuid'):
                            temp_dict['uuid'] = eachObj.get('uuid')
                        elif hostData.get('uuid'):
                            temp_dict['uuid'] = hostData.get('uuid')
                
                        temp_host_list.append(temp_dict)

            del PollManager_VC.vc_hosts[self.vc_obj.host]
            PollManager_VC.vc_hosts[self.vc_obj.host] = temp_host_list[:]
            log.debug("updating vc hosts list : %s ",PollManager_VC.vc_hosts[self.vc_obj.host])
            retValue = True
        except:
            log.exception("unable to update vcenter managed hosts")

        return retValue
    
    def getHostData(self,hostObj):
        '''
        collects uuid,hostname,hostsystem,hardware.systeminfo.model
        from hostdata that we got from CheckForUpdates call to vcenter
        returns host data in a dictionary 
        '''
        log.debug("to get host uuid list from host data of vcenter")
        
        hostDataDict = {}
        try:
            hostSystemObj = hostObj.obj
            log.debug("hostSystemObj type is :%s",hostSystemObj)
            
            if hostSystemObj:
                moref = getattr(hostSystemObj, '_moId', None)
                mo_type = getattr(hostSystemObj, '_wsdlName', None)
                if mo_type == 'HostSystem':
                    hostDataDict['moId'] = moref

            for eachChange in hostObj.changeSet:
                try:
                    if hasattr(eachChange, 'name') and eachChange.name == "hardware.systemInfo.uuid" and hasattr(eachChange, 'val'):
                        hostDataDict['uuid'] = eachChange.val
                    elif hasattr(eachChange, 'name') and eachChange.name == "hardware.systemInfo.model" and hasattr(eachChange, 'val'):
                        hostDataDict['model'] = eachChange.val
                    elif hasattr(eachChange, 'name') and eachChange.name == "name" and hasattr(eachChange, 'val'):
                        hostDataDict['name'] = eachChange.val
                    else:
                        pass
                except:
                    log.exception("Unable to get host data for this host from vcenter.")
                    
            log.debug(" uuid data is : %s",hostDataDict)
        except:
            log.exception("Unable to collect host data from vcenter")
            
        return hostDataDict
    
    def processCheckForUpdate(self):
        versionStr = ""
        host_uuid_data = []
        
        filter = self.vc_obj.retrieve_list()
        hostdata = self.vc_obj.checkHostUpdates()
        log.debug("hostdata for vcenter %s: %s",self.vc_obj.host,hostdata)
        try:
            if hostdata:
                versionStr = hostdata.version
                for eachHostObj in hostdata.filterSet[0].objectSet:
                    temp_data = None
                    try:
                        temp_data = self.getHostData(eachHostObj)
                    except:
                        log.exception("unable to get details from the data we from checkforupdates call ")
                    if temp_data:
                        host_uuid_data.append(temp_data)

            log.debug("host data from vcenter is : %s",host_uuid_data)
        except Exception as e:
            log.exception("unable to retrieve hosts from vcenter.")
            log.exception(e)
        return versionStr, host_uuid_data
    
    def stop(self):
        self._stopevent.set()
